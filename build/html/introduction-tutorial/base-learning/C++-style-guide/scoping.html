<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" data-content_root="../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2. 作用域 &mdash; IMCA-VISION_DOCUMENTATION v1.2 文档</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=7fb3a1ff"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../_static/translations.js?v=beaddf03"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../search.html" />
    <link rel="next" title="3. 类" href="classes.html" />
    <link rel="prev" title="1. 头文件" href="headers.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            IMCA-VISION_DOCUMENTATION
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../../root/introduction-tutorial.html">教程</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../base-learning.html">入门</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../ubuntu-install.html">Ubuntu (22.04版本)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../start-in-ubuntu.html">开始使用Ubuntu</a></li>
<li class="toctree-l3"><a class="reference internal" href="../VPN.html">关于vpn</a></li>
<li class="toctree-l3"><a class="reference internal" href="../the-IDE.html">IDE的安装和配置</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cmake-tool.html">cmake安装和基本使用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../git-and-github.html">Git和github</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../C%2B%2B-style-guide.html">c++代码风格规范</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="headers.html">1. 头文件</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">2. 作用域</a></li>
<li class="toctree-l4"><a class="reference internal" href="classes.html">3. 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="functions.html">4. 函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="magic.html">5. 来自 Google 的奇技</a></li>
<li class="toctree-l4"><a class="reference internal" href="others.html">6. 其他 C++ 特性</a></li>
<li class="toctree-l4"><a class="reference internal" href="naming.html">7. 命名约定</a></li>
<li class="toctree-l4"><a class="reference internal" href="comments.html">8. 注释</a></li>
<li class="toctree-l4"><a class="reference internal" href="formatting.html">9. 格式</a></li>
<li class="toctree-l4"><a class="reference internal" href="exceptions.html">10. 规则特例</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../advanced-teaching.html">进阶</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../root/quick-start.html">快速开始</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../root/ros-co-simulation.html">ros联合仿真</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">IMCA-VISION_DOCUMENTATION</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../root/introduction-tutorial.html">教程</a></li>
          <li class="breadcrumb-item"><a href="../../base-learning.html">入门</a></li>
          <li class="breadcrumb-item"><a href="../C%2B%2B-style-guide.html">c++代码风格规范</a></li>
      <li class="breadcrumb-item active">2. 作用域</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>2. 作用域<a class="headerlink" href="#id1" title="Link to this heading"></a></h1>
<section id="namespaces">
<span id="id2"></span><h2>2.1. 命名空间<a class="headerlink" href="#namespaces" title="Link to this heading"></a></h2>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>除了少数特殊情况, 应该在命名空间 (namespace) 内放置代码. 命名空间应该有独一无二的名字, 其中包含项目名称, 也可以选择性地包含文件路径. 禁止使用 using 指令 (例如 <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span> <span class="pre">foo</span></code>). 禁止使用内联 (inline) 命名空间. 请参见 <a class="reference internal" href="#internal-linkage"><span class="std std-ref">内部链接</span></a> 中关于匿名命名空间 (unamed namespace) 的内容.</p>
</div>
<p><strong>定义:</strong></p>
<blockquote>
<div><p>命名空间可以将全局作用域 (global scope) 划分为独立的、有名字的作用域, 因此可以有效防止全局作用域中的命名冲突 (name collision).</p>
</div></blockquote>
<p><strong>优点:</strong></p>
<blockquote>
<div><p>命名空间可以避免大型程序中的命名冲突, 同时代码可以继续使用简短的名称.</p>
<p>举例来说, 若两个项目的全局作用域中都有一个叫 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 的类 (class), 这两个符号 (symbol) 会在编译或运行时发生冲突. 如果每个项目在不同的命名空间中放置代码, <code class="docutils literal notranslate"><span class="pre">project1::Foo</span></code> 和 <code class="docutils literal notranslate"><span class="pre">project2::Foo</span></code> 就是截然不同的符号, 不会冲突.</p>
<p>内联命名空间会自动把其中的标识符置入外层作用域, 比如：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">outer</span><span class="w"> </span><span class="p">{</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">inner</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">();</span>
<span class="p">}</span><span class="w">  </span><span class="c1">// namespace inner</span>
<span class="p">}</span><span class="w">  </span><span class="c1">// namespace outer</span>
</pre></div>
</div>
<p>此时表达式 <code class="docutils literal notranslate"><span class="pre">outer::inner::foo()</span></code> 与 <code class="docutils literal notranslate"><span class="pre">outer::foo()</span></code> 等效. 内联命名空间的主要用途是保持不同 ABI 版本之间的兼容性。</p>
</div></blockquote>
<p><strong>缺点:</strong></p>
<blockquote>
<div><p>命名空间让人难以理解, 因为难以找到一个标识符所对应的定义.</p>
<p>内联命名空间更难理解, 因为其中的标识符不仅仅出现在声明它的命名空间中. 因此内联命名空间只能作为版本控制策略的一部分.</p>
<p>部分情景下, 我们必须多次使用完全限定名称 (fully-qualified name) 来引用符号. 此时多层嵌套的命名空间会让代码冗长.</p>
</div></blockquote>
<p><strong>结论:</strong></p>
<blockquote>
<div><p>建议按如下方法使用命名空间:</p>
<ul>
<li><p>遵守 <a class="reference external" href="naming.html#namespace-names">命名空间命名</a> 规则.</p></li>
<li><p>像前面的例子一样, 用注释给命名空间收尾. (译者注: 注明命名空间的名字.)</p></li>
<li><p>在导入语句、 <a class="reference external" href="https://gflags.github.io/gflags/">gflags</a> 声明/定义以及其他命名空间的类的前向声明 (forward declaration) 之后, 用命名空间包裹整个源代码文件:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// .h 文件</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">mynamespace</span><span class="w"> </span><span class="p">{</span>

<span class="c1">// 所有声明都位于命名空间中.</span>
<span class="c1">// 注意没有缩进.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Foo</span><span class="p">();</span>
<span class="p">};</span>

<span class="p">}</span><span class="w">  </span><span class="c1">// namespace mynamespace</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// .cpp 文件</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">mynamespace</span><span class="w"> </span><span class="p">{</span>

<span class="c1">// 函数定义位于命名空间中.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">MyClass::Foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>

<span class="p">}</span><span class="w">  </span><span class="c1">// namespace mynamespace</span>
</pre></div>
</div>
<p>更复杂的 <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> 文件有更多细节, 比如旗标 (flag) 或 using 声明.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;a.h&quot;</span>

<span class="n">DEFINE_FLAG</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">someflag</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;某个旗标&quot;</span><span class="p">);</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">mynamespace</span><span class="w"> </span><span class="p">{</span>

<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">foo</span><span class="o">::</span><span class="n">Bar</span><span class="p">;</span>

<span class="p">...</span><span class="n">命名空间内的代码</span><span class="p">...</span><span class="w">  </span><span class="c1">// 代码紧贴左边框.</span>

<span class="p">}</span><span class="w">  </span><span class="c1">// namespace mynamespace</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>若要将自动生成的 proto 消息代码放入命名空间, 可以在 <code class="docutils literal notranslate"><span class="pre">.proto</span></code> 文件中使用 <code class="docutils literal notranslate"><span class="pre">package</span></code> 修饰符 (specifier). 参见 <a class="reference external" href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated#package">Protocol Buffer 的包</a>.</p></li>
<li><p>不要在 <code class="docutils literal notranslate"><span class="pre">std</span></code> 命名空间内声明任何东西. 不要前向声明 (forward declare) 标准库的类. 在 <code class="docutils literal notranslate"><span class="pre">std</span></code> 命名空间内声明实体是未定义行为 (undefined behavior), 也就是会损害可移植性. 若要声明标准库的实体, 应该导入对应的头文件.</p></li>
<li><p>禁止使用 <em>using 指令</em> 引入命名空间的所有符号。</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 禁止: 这会污染命名空间.</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">foo</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>除了在明显标注为内部使用的命名空间内, 不要让头文件引入命名空间别名 (namespace alias). 这是因为头文件的命名空间中引入的任何东西都是该文件的公开 API. 正确示例:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 在 .cc 中, 用别名缩略常用的名称.</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">baz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">::</span><span class="nn">foo</span><span class="o">::</span><span class="nn">bar</span><span class="o">::</span><span class="nn">baz</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 在 .h 中, 用别名缩略常用的命名空间.</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">librarian</span><span class="w"> </span><span class="p">{</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">impl</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// 仅限内部使用, 不是 API.</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">sidetable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">::</span><span class="nn">pipeline_diagnostics</span><span class="o">::</span><span class="nn">sidetable</span><span class="p">;</span>
<span class="p">}</span><span class="w">  </span><span class="c1">// namespace impl</span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">my_inline_function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 一个函数 (f或方法) 中的局部别名.</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">baz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">::</span><span class="nn">foo</span><span class="o">::</span><span class="nn">bar</span><span class="o">::</span><span class="nn">baz</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
<span class="p">}</span><span class="w">  </span><span class="c1">// namespace librarian</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>禁止内联命名空间.</p></li>
<li><p>如果命名空间的名称包含 “internal”, 代表用户不应该使用这些 API.</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Absl 以外的代码不应该使用这一内部符号.</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">absl</span><span class="o">::</span><span class="n">container_internal</span><span class="o">::</span><span class="n">ImplementationDetail</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>我们鼓励新的代码使用单行的嵌套命名空间声明, 但不强制要求.</p>
<blockquote>
<div><p>译者注: 例如</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">foo</span><span class="o">::</span><span class="nn">bar</span><span class="w"> </span><span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span><span class="w">  </span><span class="c1">// namespace foo::bar</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</section>
<section id="internal-linkage">
<span id="id4"></span><h2>2.2. 内部链接<a class="headerlink" href="#internal-linkage" title="Link to this heading"></a></h2>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>若其他文件不需要使用 <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> 文件中的定义, 这些定义可以放入匿名命名空间 (unnamed namespace) 或声明为 <code class="docutils literal notranslate"><span class="pre">static</span></code>, 以实现内部链接 (internal linkage). 但是不要在 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 文件中使用这些手段.</p>
</div>
<p><strong>定义:</strong></p>
<blockquote>
<div><p>所有放入匿名命名空间中的声明都会内部链接. 声明为 <code class="docutils literal notranslate"><span class="pre">static</span></code> 的函数和变量也会内部链接. 这意味着其他文件不能访问你声明的任何事物. 即使另一个文件声明了一模一样的名称, 这两个实体也都是相互独立的.</p>
</div></blockquote>
<p><strong>结论:</strong></p>
<blockquote>
<div><p>建议 <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> 文件中所有不需要外部使用的代码采用内部链接. 不要在 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 文件中使用内部链接.</p>
<p>匿名命名空间的声明应与具名命名空间的格式相同. 在末尾的注释中, 不用填写命名空间名称:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span><span class="w">  </span><span class="c1">// namespace</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="nonmember-static-member-and-global-functions">
<span id="id5"></span><h2>2.3. 非成员函数、静态成员函数和全局函数<a class="headerlink" href="#nonmember-static-member-and-global-functions" title="Link to this heading"></a></h2>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>建议将非成员 (nonmember) 函数放入命名空间; 尽量不要使用完全全局的函数 (completely global function). 不要仅仅为了给静态成员 (static member) 分组而使用类 (class). 类的静态方法应当和类的实例或静态数据紧密相关.</p>
</div>
<p><strong>优点:</strong></p>
<blockquote>
<div><p>非成员函数和静态成员函数在某些情况下有用. 若将非成员函数放在命名空间内, 不会污染全局命名空间.</p>
</div></blockquote>
<p><strong>缺点:</strong></p>
<blockquote>
<div><p>有时非成员函数和静态成员函数更适合成为一个新的类的成员, 尤其是当它们需要访问外部资源或有明显的依赖关系时.</p>
</div></blockquote>
<p><strong>结论:</strong></p>
<blockquote>
<div><p>有时我们需要定义一个和类的实例无关的函数. 这样的函数可以定义为静态成员函数或非成员函数. 非成员函数不应该依赖外部变量, 且大部分情况下应该位于命名空间中. 不要仅仅为了给静态成员分组而创建一个新类; 这相当于给所有名称添加一个公共前缀, 而这样的分组通常是不必要的.</p>
<p>如果你定义的非成员函数仅供本 <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> 文件使用, 请用 <a class="reference internal" href="#internal-linkage"><span class="std std-ref">内部链接</span></a> 限制其作用域.</p>
</div></blockquote>
</section>
<section id="local-variables">
<span id="id6"></span><h2>2.4. 局部变量<a class="headerlink" href="#local-variables" title="Link to this heading"></a></h2>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>应该尽可能缩小函数变量的作用域 (scope), 并在声明的同时初始化.</p>
</div>
<p>你可以在 C++ 函数的任何位置声明变量. 我们提倡尽可能缩小变量的作用域, 且声明离第一次使用的位置越近越好. 这样读者更容易找到声明, 了解变量的类型和初始值. 特别地, 应该直接初始化变量而非先声明再赋值, 比如:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">();</span><span class="w">     </span><span class="c1">// 不好: 初始化和声明分离.</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="c1">// 良好: 声明时初始化​。</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">jobs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NumJobs</span><span class="p">();</span>
<span class="c1">// 更多代码...</span>
<span class="n">f</span><span class="p">(</span><span class="n">jobs</span><span class="p">);</span><span class="w">      </span><span class="c1">// 不好: 初始化和使用位置分离.</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">jobs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NumJobs</span><span class="p">();</span>
<span class="n">f</span><span class="p">(</span><span class="n">jobs</span><span class="p">);</span><span class="w">      </span><span class="c1">// 良好: 初始化以后立即 (或很快) 使用.</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// 用花括号初始化更好.</span>
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">};</span><span class="w"> </span><span class="c1">// 良好: 立即初始化 v.</span>
</pre></div>
</div>
</div></blockquote>
<p>通常应该在语句内声明用于 <code class="docutils literal notranslate"><span class="pre">if</span></code>、<code class="docutils literal notranslate"><span class="pre">while</span></code> 和 <code class="docutils literal notranslate"><span class="pre">for</span></code> 语句的变量, 这样会把作用域限制在语句内. 例如:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strchr</span><span class="p">(</span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;/&#39;</span><span class="p">))</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<p>需要注意的是, 如果变量是一个对象, 那么它每次进入作用域时会调用构造函数, 每次退出作用域时都会调用析构函数.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 低效的实现:</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1000000</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Foo</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w">  </span><span class="c1">// 调用 1000000 次构造函数和析构函数.</span>
<span class="w">    </span><span class="n">f</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在循环的作用域外面声明这类变量更高效:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Foo</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w">  </span><span class="c1">// 调用 1 次构造函数和析构函数.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1000000</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">f</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="static-and-global-variables">
<span id="id7"></span><h2>2.5. 静态和全局变量<a class="headerlink" href="#static-and-global-variables" title="Link to this heading"></a></h2>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>禁止使用 <a class="reference external" href="http://zh.cppreference.com/w/cpp/language/storage_duration#.E5.AD.98.E5.82.A8.E6.9C.9F">静态储存周期 (static storage duration)</a> 的变量, 除非它们可以 <a class="reference external" href="https://zh.cppreference.com/w/cpp/types/is_destructible">平凡地析构 (trivially destructible)</a>. 简单来说, 就是析构函数 (destructor) 不会做任何事情, 包括成员和基类 (base) 的析构函数. 正式地说, 就是这一类型 (type) 没有用户定义的析构函数或虚析构函数 (virtual destructor), 且所有成员和基类也能平凡地析构. 函数的局部静态变量可以动态地初始化 (dynamic initialization) . 除了少数情况外, 不推荐动态初始化静态类成员变量或命名空间内的变量. 详情参见下文.</p>
</div>
<p>作为经验之谈: 若只看全局变量的声明, 如果该语句可以作为常量表达式 (constexpr), 则满足以上要求.</p>
<p><strong>定义:</strong></p>
<blockquote>
<div><p>每个对象 (object) 都有与生命周期 (linetime) 相关的储存周期 (storage duration). 静态储存周期对象的存活时间是从程序初始化开始, 到程序结束为止. 这些对象可能是命名空间作用域内的变量 (全局变量)、类的静态数据成员或者用 <code class="docutils literal notranslate"><span class="pre">static</span></code> 修饰符 (specifier) 声明的函数局部变量. 对于函数局部静态变量, 初始化发生在在控制流第一次经过声明时; 所有其他对象会在程序启动时初始化. 程序退出时会销毁所有静态储存周期的对象 (这发生在未汇合 (join) 的线程终止前).</p>
<p>初始化过程可以是动态 (dynamic) 的, 也就是初始化过程中有不平凡 (non-trivial) 的操作. (例如, 会分配内存的构造函数, 或者用当前进程 ID 初始化的变量.) 其他初始化都是静态 (static) 初始化. 二者并非水火不容: 静态储存周期的变量 <strong>一定</strong> 会静态初始化 (初始化为指定常量或给所有字节清零), 必要时会随后再次动态初始化.</p>
</div></blockquote>
<p><strong>优点:</strong></p>
<blockquote>
<div><p>全局或静态变量对很多场景有帮助: 具名常量 (named constants)、编译单元 (translation unit) 内部的辅助数据结构、命令行旗标 (flag)、日志、注册机制、后台基础设施等等.</p>
</div></blockquote>
<p><strong>缺点:</strong></p>
<blockquote>
<div><p>使用动态初始化或具有非平凡析构函数的全局和静态变量时, 会增加代码复杂度, 容易引发难以察觉的错误. 不同编译单元的动态初始化顺序不确定, 析构顺序也不确定 (只知道析构顺序一定是初始化顺序的逆序). 如果静态变量的初始化代码引用了另一个静态储存周期的变量, 这次访问可能发生在另一变量的生命周期开始前 (或生命周期结束后). 此外, 若有些线程没有在程序结束前汇合, 这些线程可能在静态变量析构后继续访问这些变量.</p>
</div></blockquote>
<p><strong>决定:</strong></p>
<blockquote>
<div><p><strong>关于析构的决定</strong></p>
<p>平凡的析构函数不受执行顺序影响 (他们实际上不算”执行”); 其他析构函数则有风险, 可能访问生命周期已结束的对象. 因此, 只有拥有平凡析构函数的对象才能采用静态储存周期. 基本类型 (例如指针和 <code class="docutils literal notranslate"><span class="pre">int</span></code>) 可以平凡地析构, 可平凡析构的类型所构成的数组也可以平凡地析构. 注意, 用 <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> 修饰的变量可以平凡地析构.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">kNum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">  </span><span class="c1">// 允许</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">X</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="k">const</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="n">kX</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">2</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">3</span><span class="p">}};</span><span class="w">  </span><span class="c1">// 允许</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">kMessages</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;world&quot;</span><span class="p">};</span><span class="w">  </span><span class="c1">// 允许</span>
<span class="p">}</span>

<span class="c1">// 允许: constexpr 可以保证析构函数是平凡的.</span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">kArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不好: 非平凡的析构.</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">kFoo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foo&quot;</span><span class="p">;</span>

<span class="c1">// 和上面相同的原因, 即使 kBar 是引用 (该规则也适用于生命周期被延长的临时对象).</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">kBar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">StrCat</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;c&quot;</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 不好: 非平凡的析构.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">kData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意, 引用不是对象, 因此它们的析构函数不受限. 但是, 它们仍需遵守动态初始化的限制. 特别地, 我们允许形如 <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">T&amp;</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">*new</span> <span class="pre">T;</span></code> 的函数内局部静态引用.</p>
<p><strong>关于初始化的决定</strong></p>
<p>初始化是更复杂的话题, 因为我们不仅需要考虑构造函数的执行过程, 也要考虑初始化表达式 (initializer) 的求值过程.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">    </span><span class="c1">// 可以</span>
<span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">();</span><span class="w">  </span><span class="c1">// ? (依赖 f)</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">        </span><span class="c1">// ? (依赖 Foo::Foo)</span>
<span class="n">Bar</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">();</span><span class="w">  </span><span class="c1">// ? (依赖 g 和 Bar::Bar)</span>
</pre></div>
</div>
<p>除了第一行语句以外, 其他语句都会受到不确定的初始化顺序影响.</p>
<p>我们所需的概念在 C++ 标准中的正式称谓是常量初始化 (constant initialization). 这意味着初始化表达式是常量表达式 (constant expression), 并且如果要用构造函数进行初始化, 则该构造函数也必须声明为 <code class="docutils literal notranslate"><span class="pre">constexpr</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">  </span><span class="c1">// 可以, 5 是常量表达式.</span>
<span class="n">Foo</span><span class="w"> </span><span class="nf">x</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w">   </span><span class="c1">// 可以, 2 是常量表达式且被选中的构造函数也是 constexpr.</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">a</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w">  </span><span class="c1">// 可以</span>
</pre></div>
</div>
<p>可以自由使用常量初始化. 应该用 <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> 或 <code class="docutils literal notranslate"><span class="pre">constinit</span></code> 标记静态变量的常量初始化过程. 应该假设任何没有这些标记的静态变量都是动态初始化的, 并谨慎地检查这些代码.</p>
<p>作为反例, 以下初始化过程有问题:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 下文使用了这些声明.</span>
<span class="kt">time_t</span><span class="w"> </span><span class="nf">time</span><span class="p">(</span><span class="kt">time_t</span><span class="o">*</span><span class="p">);</span><span class="w">      </span><span class="c1">// 不是 constexpr!</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">f</span><span class="p">();</span><span class="w">                   </span><span class="c1">// 不是 constexpr!</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Bar</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Bar</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="p">};</span>

<span class="c1">// 有问题的初始化.</span>
<span class="kt">time_t</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">time</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span><span class="w">  </span><span class="c1">// 初始化表达式不是常量表达式.</span>
<span class="n">Foo</span><span class="w"> </span><span class="nf">y</span><span class="p">(</span><span class="n">f</span><span class="p">());</span><span class="w">                </span><span class="c1">// 同上</span>
<span class="n">Bar</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w">                     </span><span class="c1">// 被选中的构造函数 Bar::Bar() 不是 constexpr.</span>
</pre></div>
</div>
<p>我们不建议且通常禁止动态地初始化全局变量. 不过, 如果这一初始化过程不依赖于其他初始化过程的顺序, 则可以允许. 若满足这一要求, 则初始化的顺序变化不会产生任何区别. 例如:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getpid</span><span class="p">();</span><span class="w">  </span><span class="c1">// 若其他静态变量不会在初始化过程中使用 p, 则允许.</span>
</pre></div>
</div>
<p>允许动态地初始化静态局部变量 (这是常见的).</p>
<p><strong>常用的语法结构</strong></p>
<ul class="simple">
<li><p>全局字符串: 如果你需要具名的 (named) 全局或静态字符串常量, 可以采用 <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> 修饰的 <code class="docutils literal notranslate"><span class="pre">string_view</span></code> 变量、字符数组或指向字符串字面量 (literal) 的字符指针. 字符串字面量具有静态储存周期, 因此通常能满足需要. 参见 <a class="reference external" href="https://abseil.io/tips/140">第 140 号每周提示</a>.</p></li>
<li><p>字典和集合等动态容器 (container): 若你需要用静态变量储存不会改变的数据 (例如用于搜索的集合或查找表), 不要使用标准库的动态容器, 因为这些容器拥有非平凡的析构函数. 可以考虑用平凡类型的数组替代, 例如 <code class="docutils literal notranslate"><span class="pre">int</span></code> 数组的数组 (作为把 <code class="docutils literal notranslate"><span class="pre">int</span></code> 映射到 <code class="docutils literal notranslate"><span class="pre">int</span></code> 的字典) 或者数对 (pair) 的数组 (例如一组 <code class="docutils literal notranslate"><span class="pre">int</span></code> 和 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char*</span></code> 的数对). 对于少量数据, 线性搜索就足够了, 而且因为具有内存局部性 (memory locality) 而更加高效; 可以使用 <a class="reference external" href="https://github.com/abseil/abseil-cpp/blob/master/absl/algorithm/container.h">absl/algorithm/container.h</a> 中的工具实现常见操作. 如有需要, 可以保持数据有序并采用二分查找法 (binary search). 如果你确实需要使用标准库的动态容器, 建议使用如下文所述的函数内局部静态指针.</p></li>
<li><p>智能指针 (smart pointer, 例如 <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code> 和 <code class="docutils literal notranslate"><span class="pre">std::shared_ptr</span></code>) 在析构时有释放资源的操作, 因此不能作为静态变量. 请思考你的情景是否适用于本小节描述的其他模式. 简单的解决方式是, 用裸指针 (plain pointer) 指向动态分配的对象, 并且永远不删除这个对象 (参见最后一点).</p></li>
<li><p>自定义类型的静态变量: 如果静态数据或常量数据是自定义类型, 请给这一类型设置平凡的析构函数和 <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> 修饰的构造函数.</p></li>
<li><p>若以上都不适用, 你可以采用函数内局部静态指针或引用, 动态分配一个对象且永不删除 (例如 <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">const</span> <span class="pre">auto&amp;</span> <span class="pre">impl</span> <span class="pre">=</span> <span class="pre">*new</span> <span class="pre">T(args...);</span></code>).</p></li>
</ul>
</div></blockquote>
</section>
<section id="thread-local">
<h2>2.6. thread_local 变量<a class="headerlink" href="#thread-local" title="Link to this heading"></a></h2>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>必须使用编译期常量 (compile-time constant) 初始化在函数外定义的 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 变量, 且必须使用 <a class="reference external" href="https://github.com/abseil/abseil-cpp/blob/master/absl/base/attributes.h">ABSL_CONST_INIT</a> 属性来强制执行这一规则. 优先采用 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code>, 而非其他定义线程内局部数据的方法.</p>
</div>
<p><strong>定义:</strong></p>
<blockquote>
<div><p>我们可以用 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 修饰符声明变量:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">thread_local</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
</pre></div>
</div>
<p>这样的变量本质上其实是一组不同的对象. 不同线程访问该变量时, 会访问各自的对象. <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 变量在很多方面类似于 <a class="reference internal" href="#static-and-global-variables"><span class="std std-ref">静态储存周期的变量</span></a>. 例如, 可以在命名空间内、函数内或类的静态成员内声明这些变量, 但不能在类的普通成员内声明它们.</p>
<p><code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 实例与静态变量的初始化过程类似, 区别是 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 实例会在每个线程启动时初始化, 而非程序启动时初始化. 这意味着函数内的 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 变量是线程安全的. 若要访问其他 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 变量, 则有跟静态变量一样的初始化顺序问题 (而且问题更大).</p>
<p><code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 的变量也有微妙的析构顺序问题: 线程终止时, <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 的销毁顺序是初始化顺序的逆序 (正如 C++ 在其他部分的规则一样). 如果 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 的变量在析构过程中访问了该线程中已销毁的其他 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 变量, 就会出现难以调试的释放后使用 (use-after-free, 即野指针) 问题.</p>
</div></blockquote>
<p><strong>优点:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>线程的局部数据可以从根本上防止竞态条件 (race) (因为通常只有一个线程访问), 因此 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 能帮助并行化.</p></li>
<li><p>在创建线程局部数据的各种方法中, <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 是由语法标准支持的唯一方法.</p></li>
</ul>
</div></blockquote>
<p><strong>缺点:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>在线程启动或首次使用 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 变量时, 可能触发很多难以预测、运行时间不可控的其他代码.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 本质上是全局变量. 除了线程安全以外, 它具有全局变量的所有其他缺点.</p></li>
<li><p>在最坏情况下, <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 变量占用的内存与线程数量成正比, 占用量可能十分巨大.</p></li>
<li><p>成员数据 (data member) 必须是静态的才能声明为 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code>.</p></li>
<li><p>若 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 变量拥有复杂的析构函数, 我们可能遇到野指针. 特别地, 析构函数不能 (直接或间接地) 访问任何有可能已被销毁的其他 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 变量. 我们难以检查这一规则.</p></li>
<li><p>那些用于全局/静态变量的、预防野指针的方法不适用于 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code>. 展开来说, 我们可以跳过全局或局部变量的析构函数, 因为他们的生命周期会随着程序终止而自然结束. 因此, 操作系统很快就会回收泄露的内存和其他资源. 然而, 若跳过 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 的析构函数, 那么资源泄漏量和程序运行期间创建的线程数量成正比.</p></li>
</ul>
</div></blockquote>
<p><strong>决定:</strong></p>
<blockquote>
<div><p>位于类或命名空间中的 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 变量只能用真正的编译时常量来初始化  (也就是不能动态初始化). 必须用 <a class="reference external" href="https://github.com/abseil/abseil-cpp/blob/master/absl/base/attributes.h">ABSL_CONST_INIT</a> 修饰来保证这一点 (也可以用 <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> 修饰, 但不常见).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ABSL_CONST_INIT</span><span class="w"> </span><span class="k">thread_local</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
</pre></div>
</div>
<p>函数中的 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 变量没有初始化的顾虑, 但是在线程退出时有释放后使用的风险. 注意, 你可以用静态方法暴露函数内的 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 变量, 来模拟类或命名空间中的 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 变量:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Foo</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">MyThreadLocalFoo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">thread_local</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ComplicatedInitialization</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意, 线程退出时会销毁 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 变量. 如果析构函数使用了任何其他 (可能已经销毁的) <code class="docutils literal notranslate"><span class="pre">thead_local</span></code> 变量, 我们会遇到难以调试的野指针. 建议使用平凡的类型, 或析构函数中没有自定义代码的类型, 以减少访问其他 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 变量的可能性.</p>
<p>建议优先使用 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> 定义线程的局部数据, 而非其他机制.</p>
</div></blockquote>
</section>
<section id="yulefox">
<h2>译者 (YuleFox) 笔记<a class="headerlink" href="#yulefox" title="Link to this heading"></a></h2>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cc</span></code> 中的匿名命名空间可避免命名冲突, 限定作用域, 避免直接使用 <code class="docutils literal notranslate"><span class="pre">using</span></code> 关键字污染命名空间;</p></li>
<li><p>嵌套类符合局部使用原则, 只是不能在其他头文件中前置声明, 尽量不要 <code class="docutils literal notranslate"><span class="pre">public</span></code>;</p></li>
<li><p>尽量不用全局函数和全局变量, 考虑作用域和命名空间限制, 尽量单独形成编译单元;</p></li>
<li><p>多线程中的全局变量 (含静态成员变量) 不要使用 <code class="docutils literal notranslate"><span class="pre">class</span></code> 类型 (含 STL 容器), 避免不明确行为导致的 bug.</p></li>
<li><p>作用域的使用, 除了考虑名称污染, 可读性之外, 主要是为降低耦合, 提高编译/执行效率.</p></li>
</ol>
</section>
<section id="acgtyrant">
<h2>译者（acgtyrant）笔记<a class="headerlink" href="#acgtyrant" title="Link to this heading"></a></h2>
<ol class="arabic simple">
<li><p>注意「using 指示（using-directive）」和「using 声明（using-declaration）」的区别。</p></li>
<li><p>匿名命名空间说白了就是文件作用域，就像 C static 声明的作用域一样，后者已经被 C++ 标准提倡弃用。</p></li>
<li><p>局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效，同时也贯彻了计算机体系结构重要的概念「局部性（locality）」。</p></li>
<li><p>注意别在循环犯大量构造和析构的低级错误。</p></li>
</ol>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="headers.html" class="btn btn-neutral float-left" title="1. 头文件" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="classes.html" class="btn btn-neutral float-right" title="3. 类" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2024, IMCA_VISION。</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>